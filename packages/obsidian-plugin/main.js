/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SageAIPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/services/ollama.ts
var import_obsidian = require("obsidian");
var OllamaService = class {
  constructor(config) {
    this.baseUrl = config.baseUrl.replace(/\/$/, "");
    this.model = config.model;
  }
  /**
   * Generate embeddings for the given text
   */
  async getEmbedding(text) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}/api/embeddings`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: this.model,
        prompt: text
      })
    });
    if (response.status !== 200) {
      throw new Error(`Ollama API error: ${response.status}`);
    }
    const data = response.json;
    return data.embedding;
  }
  /**
   * Generate embeddings for multiple texts in batch
   */
  async getEmbeddings(texts) {
    const embeddings = [];
    for (const text of texts) {
      const embedding = await this.getEmbedding(text);
      embeddings.push(embedding);
    }
    return embeddings;
  }
  /**
   * Check if Ollama server is reachable and the model is available
   */
  async healthCheck() {
    var _a;
    try {
      const tagsResponse = await (0, import_obsidian.requestUrl)({
        url: `${this.baseUrl}/api/tags`,
        method: "GET"
      });
      if (tagsResponse.status !== 200) {
        return {
          healthy: false,
          message: `Ollama server returned status ${tagsResponse.status}`
        };
      }
      const models = ((_a = tagsResponse.json) == null ? void 0 : _a.models) || [];
      const modelNames = models.map((m) => m.name);
      const hasModel = modelNames.some(
        (name) => name === this.model || name.startsWith(`${this.model}:`)
      );
      if (!hasModel) {
        return {
          healthy: false,
          message: `Model '${this.model}' not found. Available: ${modelNames.join(", ")}`
        };
      }
      return {
        healthy: true,
        message: `Connected to Ollama with model '${this.model}'`
      };
    } catch (error) {
      return {
        healthy: false,
        message: `Cannot connect to Ollama: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Update service configuration
   */
  updateConfig(config) {
    if (config.baseUrl) {
      this.baseUrl = config.baseUrl.replace(/\/$/, "");
    }
    if (config.model) {
      this.model = config.model;
    }
  }
};

// src/services/qdrant.ts
var import_obsidian2 = require("obsidian");
var QdrantService = class {
  constructor(config) {
    this.baseUrl = config.baseUrl.replace(/\/$/, "");
    this.collection = config.collection;
  }
  /**
   * Search for similar vectors
   */
  async search(vector, limit = 10, scoreThreshold = 0) {
    const response = await (0, import_obsidian2.requestUrl)({
      url: `${this.baseUrl}/collections/${this.collection}/points/search`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        vector,
        limit,
        score_threshold: scoreThreshold,
        with_payload: true
      })
    });
    if (response.status !== 200) {
      throw new Error(`Qdrant search error: ${response.status}`);
    }
    return response.json.result || [];
  }
  /**
   * Upsert points (insert or update)
   */
  async upsert(points) {
    const response = await (0, import_obsidian2.requestUrl)({
      url: `${this.baseUrl}/collections/${this.collection}/points`,
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        points: points.map((p) => ({
          id: p.id,
          vector: p.vector,
          payload: p.payload
        }))
      })
    });
    if (response.status !== 200) {
      throw new Error(`Qdrant upsert error: ${response.status}`);
    }
  }
  /**
   * Delete points by IDs
   */
  async delete(ids) {
    const response = await (0, import_obsidian2.requestUrl)({
      url: `${this.baseUrl}/collections/${this.collection}/points/delete`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        points: ids
      })
    });
    if (response.status !== 200) {
      throw new Error(`Qdrant delete error: ${response.status}`);
    }
  }
  /**
   * Delete points by filter (e.g., by file path)
   */
  async deleteByFilter(filter) {
    const response = await (0, import_obsidian2.requestUrl)({
      url: `${this.baseUrl}/collections/${this.collection}/points/delete`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        filter
      })
    });
    if (response.status !== 200) {
      throw new Error(`Qdrant delete by filter error: ${response.status}`);
    }
  }
  /**
   * Get collection info
   */
  async getCollectionInfo() {
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${this.baseUrl}/collections/${this.collection}`,
        method: "GET"
      });
      if (response.status !== 200) {
        return null;
      }
      return response.json.result;
    } catch (e) {
      return null;
    }
  }
  /**
   * Create collection if it doesn't exist
   */
  async ensureCollection(vectorSize) {
    const info = await this.getCollectionInfo();
    if (info) {
      return;
    }
    const response = await (0, import_obsidian2.requestUrl)({
      url: `${this.baseUrl}/collections/${this.collection}`,
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        vectors: {
          size: vectorSize,
          distance: "Cosine"
        }
      })
    });
    if (response.status !== 200) {
      throw new Error(`Failed to create collection: ${response.status}`);
    }
  }
  /**
   * Check if Qdrant server is reachable and collection exists
   */
  async healthCheck() {
    var _a, _b;
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${this.baseUrl}/collections`,
        method: "GET"
      });
      if (response.status !== 200) {
        return {
          healthy: false,
          message: `Qdrant server returned status ${response.status}`
        };
      }
      const collections = ((_b = (_a = response.json) == null ? void 0 : _a.result) == null ? void 0 : _b.collections) || [];
      const hasCollection = collections.some(
        (c) => c.name === this.collection
      );
      if (!hasCollection) {
        return {
          healthy: false,
          message: `Collection '${this.collection}' not found. Run index first.`
        };
      }
      return {
        healthy: true,
        message: `Connected to Qdrant with collection '${this.collection}'`
      };
    } catch (error) {
      return {
        healthy: false,
        message: `Cannot connect to Qdrant: ${error instanceof Error ? error.message : "Unknown error"}`
      };
    }
  }
  /**
   * Get all point IDs in the collection
   */
  async getAllPointIds() {
    var _a, _b, _c, _d;
    const ids = [];
    let offset = null;
    const limit = 100;
    while (true) {
      const body = {
        limit,
        with_payload: false,
        with_vector: false
      };
      if (offset !== null) {
        body.offset = offset;
      }
      const response = await (0, import_obsidian2.requestUrl)({
        url: `${this.baseUrl}/collections/${this.collection}/points/scroll`,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      if (response.status !== 200) {
        break;
      }
      const points = ((_b = (_a = response.json) == null ? void 0 : _a.result) == null ? void 0 : _b.points) || [];
      for (const point of points) {
        ids.push(point.id);
      }
      offset = (_d = (_c = response.json) == null ? void 0 : _c.result) == null ? void 0 : _d.next_page_offset;
      if (!offset) {
        break;
      }
    }
    return ids;
  }
  /**
   * Update service configuration
   */
  updateConfig(config) {
    if (config.baseUrl) {
      this.baseUrl = config.baseUrl.replace(/\/$/, "");
    }
    if (config.collection) {
      this.collection = config.collection;
    }
  }
};

// src/services/indexer.ts
var VECTOR_SIZE = 1024;
var DocumentIndexer = class {
  constructor(config) {
    this.isIndexing = false;
    this.ollama = config.ollama;
    this.qdrant = config.qdrant;
    this.app = config.app;
  }
  /**
   * Index all markdown files in the vault
   */
  async indexVault(onProgress) {
    if (this.isIndexing) {
      throw new Error("Indexing already in progress");
    }
    this.isIndexing = true;
    let indexed = 0;
    try {
      await this.qdrant.ensureCollection(VECTOR_SIZE);
      const files = this.app.vault.getMarkdownFiles();
      const total = files.length;
      for (const file of files) {
        try {
          await this.indexFile(file);
          indexed++;
          onProgress == null ? void 0 : onProgress(indexed, total, file.path);
        } catch (error) {
          console.error(`Failed to index ${file.path}:`, error);
        }
      }
      return {
        totalDocuments: indexed,
        lastIndexed: Date.now()
      };
    } finally {
      this.isIndexing = false;
    }
  }
  /**
   * Index a single file
   */
  async indexFile(file) {
    const content = await this.app.vault.cachedRead(file);
    if (!content.trim()) {
      return;
    }
    const title = file.basename;
    const textToEmbed = `${title}

${content}`;
    const maxChars = 8e3;
    const truncatedText = textToEmbed.length > maxChars ? textToEmbed.substring(0, maxChars) : textToEmbed;
    const embedding = await this.ollama.getEmbedding(truncatedText);
    const metadata = this.extractMetadata(file, content);
    const id = this.pathToId(file.path);
    await this.qdrant.upsert([
      {
        id,
        vector: embedding,
        payload: {
          path: file.path,
          title: metadata.title,
          mtime: metadata.mtime,
          size: metadata.size,
          tags: metadata.tags,
          aliases: metadata.aliases,
          excerpt: content.substring(0, 500)
        }
      }
    ]);
  }
  /**
   * Remove a file from the index
   */
  async removeFile(path) {
    const id = this.pathToId(path);
    await this.qdrant.delete([id]);
  }
  /**
   * Search for similar documents
   */
  async search(query, limit = 10, minScore = 0.3) {
    const queryEmbedding = await this.ollama.getEmbedding(query);
    const results = await this.qdrant.search(queryEmbedding, limit, minScore);
    return results.map((r) => ({
      path: r.payload.path,
      title: r.payload.title,
      score: r.score,
      excerpt: r.payload.excerpt || ""
    }));
  }
  /**
   * Check if services are healthy
   */
  async healthCheck() {
    const [ollamaHealth, qdrantHealth] = await Promise.all([
      this.ollama.healthCheck(),
      this.qdrant.healthCheck()
    ]);
    return {
      ollama: ollamaHealth,
      qdrant: qdrantHealth
    };
  }
  /**
   * Get index statistics
   */
  async getStats() {
    const info = await this.qdrant.getCollectionInfo();
    if (!info) {
      return null;
    }
    return {
      totalDocuments: info.points_count || 0,
      lastIndexed: null
      // Qdrant doesn't track this
    };
  }
  /**
   * Extract metadata from file
   */
  extractMetadata(file, content) {
    var _a, _b, _c;
    const cache = this.app.metadataCache.getFileCache(file);
    const tags = [];
    if (cache == null ? void 0 : cache.tags) {
      tags.push(...cache.tags.map((t) => t.tag));
    }
    if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) {
      const fmTags = cache.frontmatter.tags;
      if (Array.isArray(fmTags)) {
        tags.push(...fmTags.map((t) => t.startsWith("#") ? t : `#${t}`));
      } else if (typeof fmTags === "string") {
        tags.push(fmTags.startsWith("#") ? fmTags : `#${fmTags}`);
      }
    }
    const aliases = [];
    if ((_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b.aliases) {
      const fmAliases = cache.frontmatter.aliases;
      if (Array.isArray(fmAliases)) {
        aliases.push(...fmAliases);
      } else if (typeof fmAliases === "string") {
        aliases.push(fmAliases);
      }
    }
    const title = ((_c = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _c.title) || file.basename;
    return {
      path: file.path,
      title,
      mtime: file.stat.mtime,
      size: file.stat.size,
      tags: [...new Set(tags)],
      aliases
    };
  }
  /**
   * Convert file path to a numeric ID for Qdrant
   */
  pathToId(path) {
    let hash = 0;
    for (let i = 0; i < path.length; i++) {
      const char = path.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
};

// src/services/linkSuggestion.ts
var import_obsidian3 = require("obsidian");
var LinkSuggestionService = class {
  constructor(vault, ollama, qdrant) {
    this.vault = vault;
    this.ollama = ollama;
    this.qdrant = qdrant;
  }
  /**
   * Extract key phrases from document for embedding
   */
  async extractKeyPhrases(file) {
    const content = await this.vault.cachedRead(file);
    const lines = content.split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("#"));
    const firstPara = lines[0] || "";
    const headings = content.split("\n").filter((line) => line.startsWith("##")).map((line) => line.replace(/^#+\s*/, "")).slice(0, 3);
    const context = `${firstPara} ${headings.join(" ")}`;
    return context.slice(0, 500);
  }
  /**
   * Group search results by document
   */
  groupByDocument(results) {
    const docs = /* @__PURE__ */ new Map();
    for (const result of results) {
      const filePath = result.payload.path;
      const excerpt = result.payload.excerpt;
      const score = result.score;
      console.log("[LinkSuggestion] Processing result:", { filePath, score, hasExcerpt: !!excerpt });
      if (!filePath) {
        console.warn("[LinkSuggestion] No path in payload:", result.payload);
        continue;
      }
      if (!docs.has(filePath)) {
        docs.set(filePath, { score: 0, chunks: [] });
      }
      const doc = docs.get(filePath);
      doc.score = Math.max(doc.score, score);
      if (excerpt) {
        doc.chunks.push(excerpt);
      }
    }
    return docs;
  }
  /**
   * Generate Obsidian wikilink for a file
   */
  generateWikilink(file) {
    const path = file.path.replace(/\.md$/, "");
    const title = file.basename;
    return `[[${path}|${title}]]`;
  }
  /**
   * Find similar documents to the given file
   */
  async findSimilarDocuments(currentFile, limit = 8) {
    try {
      console.log("[LinkSuggestion] Finding similar documents for:", currentFile.path);
      const context = await this.extractKeyPhrases(currentFile);
      console.log("[LinkSuggestion] Extracted context:", context.slice(0, 100) + "...");
      if (!context) {
        console.warn("[LinkSuggestion] No context extracted");
        return [];
      }
      console.log("[LinkSuggestion] Getting embedding from Ollama...");
      const embedding = await this.ollama.getEmbedding(context);
      console.log("[LinkSuggestion] Embedding received, length:", embedding.length);
      console.log("[LinkSuggestion] Searching Qdrant...");
      const searchResults = await this.qdrant.search(embedding, limit + 5);
      console.log("[LinkSuggestion] Search results count:", searchResults.length);
      if (searchResults.length === 0) {
        console.warn("[LinkSuggestion] No search results from Qdrant");
        return [];
      }
      const grouped = this.groupByDocument(searchResults);
      console.log("[LinkSuggestion] Grouped documents:", grouped.size);
      const suggestions = [];
      const currentPath = currentFile.path;
      for (const [filePath, data] of grouped.entries()) {
        console.log("[LinkSuggestion] Processing:", filePath, "score:", data.score);
        if (filePath === currentPath) {
          console.log("[LinkSuggestion] Skipping current file");
          continue;
        }
        const file = this.vault.getAbstractFileByPath(filePath);
        if (!(file instanceof import_obsidian3.TFile)) {
          console.warn("[LinkSuggestion] File not found:", filePath);
          continue;
        }
        suggestions.push({
          file,
          score: data.score,
          snippets: data.chunks,
          wikilink: this.generateWikilink(file)
        });
        if (suggestions.length >= limit)
          break;
      }
      suggestions.sort((a, b) => b.score - a.score);
      console.log("[LinkSuggestion] Final suggestions count:", suggestions.length);
      return suggestions;
    } catch (error) {
      console.error("[LinkSuggestion] Error finding similar documents:", error);
      throw error;
    }
  }
};

// src/ui/SearchModal.ts
var import_obsidian4 = require("obsidian");
var SearchModal = class extends import_obsidian4.Modal {
  constructor(app, indexer, maxResults = 10, minScore = 0.3) {
    super(app);
    this.results = [];
    this.indexer = indexer;
    this.maxResults = maxResults;
    this.minScore = minScore;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("sage-ai-search-modal");
    contentEl.createEl("h2", { text: "Sage AI: Semantic Search" });
    const inputContainer = contentEl.createDiv({
      cls: "sage-ai-search-input-container"
    });
    this.inputEl = inputContainer.createEl("input", {
      type: "text",
      placeholder: "Search by meaning...",
      cls: "sage-ai-search-input"
    });
    this.inputEl.focus();
    this.statusEl = contentEl.createDiv({ cls: "sage-ai-search-status" });
    this.statusEl.setText("Type to search");
    this.resultsContainer = contentEl.createDiv({
      cls: "sage-ai-search-results"
    });
    const debouncedSearch = (0, import_obsidian4.debounce)(
      async (query) => {
        if (query.length < 2) {
          this.statusEl.setText("Type at least 2 characters");
          this.resultsContainer.empty();
          return;
        }
        this.statusEl.setText("Searching...");
        try {
          this.results = await this.indexer.search(
            query,
            this.maxResults,
            this.minScore
          );
          this.renderResults();
          if (this.results.length === 0) {
            this.statusEl.setText("No results found");
          } else {
            this.statusEl.setText(
              `Found ${this.results.length} result${this.results.length === 1 ? "" : "s"}`
            );
          }
        } catch (error) {
          console.error("Search error:", error);
          this.statusEl.setText(
            `Error: ${error instanceof Error ? error.message : "Search failed"}`
          );
        }
      },
      300,
      true
    );
    this.inputEl.addEventListener("input", () => {
      debouncedSearch(this.inputEl.value);
    });
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        this.close();
      } else if (e.key === "Enter" && this.results.length > 0) {
        this.openResult(this.results[0]);
      }
    });
  }
  renderResults() {
    this.resultsContainer.empty();
    for (const result of this.results) {
      const resultEl = this.resultsContainer.createDiv({
        cls: "sage-ai-search-result"
      });
      const titleRow = resultEl.createDiv({ cls: "sage-ai-result-title-row" });
      titleRow.createSpan({ text: result.title, cls: "sage-ai-result-title" });
      titleRow.createSpan({
        text: `${Math.round(result.score * 100)}%`,
        cls: "sage-ai-result-score"
      });
      resultEl.createDiv({
        text: result.path,
        cls: "sage-ai-result-path"
      });
      if (result.excerpt) {
        const excerptText = result.excerpt.length > 150 ? result.excerpt.substring(0, 150) + "..." : result.excerpt;
        resultEl.createDiv({
          text: excerptText,
          cls: "sage-ai-result-excerpt"
        });
      }
      resultEl.addEventListener("click", () => {
        this.openResult(result);
      });
    }
  }
  async openResult(result) {
    const file = this.app.vault.getAbstractFileByPath(result.path);
    if (file) {
      await this.app.workspace.openLinkText(result.path, "", false);
      this.close();
    } else {
      new import_obsidian4.Notice(`File not found: ${result.path}`);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/JumpModal.ts
var import_obsidian5 = require("obsidian");
var JumpModal = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app) {
    super(app);
    this.setPlaceholder("Jump to document...");
    this.setInstructions([
      { command: "\u2191\u2193", purpose: "navigate" },
      { command: "\u21B5", purpose: "open" },
      { command: "esc", purpose: "dismiss" }
    ]);
  }
  getItems() {
    return this.app.vault.getMarkdownFiles().sort((a, b) => {
      return b.stat.mtime - a.stat.mtime;
    });
  }
  getItemText(file) {
    return file.path.replace(/\.md$/, "");
  }
  renderSuggestion(match, el) {
    const file = match.item;
    const container = el.createDiv({ cls: "sage-ai-jump-suggestion" });
    container.createDiv({
      text: file.basename,
      cls: "sage-ai-jump-title"
    });
    if (file.parent && file.parent.path !== "/") {
      container.createDiv({
        text: file.parent.path,
        cls: "sage-ai-jump-path"
      });
    }
    const mtime = new Date(file.stat.mtime);
    const timeAgo = this.formatTimeAgo(mtime);
    container.createDiv({
      text: timeAgo,
      cls: "sage-ai-jump-mtime"
    });
  }
  onChooseItem(file) {
    this.app.workspace.openLinkText(file.path, "", false);
  }
  formatTimeAgo(date) {
    const now = /* @__PURE__ */ new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 6e4);
    const diffHours = Math.floor(diffMs / 36e5);
    const diffDays = Math.floor(diffMs / 864e5);
    if (diffMins < 1) {
      return "just now";
    } else if (diffMins < 60) {
      return `${diffMins}m ago`;
    } else if (diffHours < 24) {
      return `${diffHours}h ago`;
    } else if (diffDays < 7) {
      return `${diffDays}d ago`;
    } else {
      return date.toLocaleDateString();
    }
  }
};

// src/ui/IndexModal.ts
var import_obsidian6 = require("obsidian");
var IndexModal = class extends import_obsidian6.Modal {
  constructor(app, indexer) {
    super(app);
    this.isIndexing = false;
    this.indexer = indexer;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("sage-ai-index-modal");
    contentEl.createEl("h2", { text: "Sage AI: Rebuild Index" });
    contentEl.createEl("p", {
      text: "This will re-index all markdown files in your vault. Existing index data will be updated.",
      cls: "sage-ai-index-description"
    });
    const progressContainer = contentEl.createDiv({
      cls: "sage-ai-progress-container"
    });
    this.progressEl = progressContainer.createDiv({
      cls: "sage-ai-progress-bar"
    });
    this.statusEl = contentEl.createDiv({ cls: "sage-ai-index-status" });
    const buttonContainer = contentEl.createDiv({
      cls: "sage-ai-button-container"
    });
    this.buttonEl = buttonContainer.createEl("button", {
      text: "Start Indexing",
      cls: "mod-cta"
    });
    this.buttonEl.addEventListener("click", () => {
      this.startIndexing();
    });
    this.checkHealth();
  }
  async checkHealth() {
    this.statusEl.setText("Checking connections...");
    try {
      const health = await this.indexer.healthCheck();
      if (!health.ollama.healthy) {
        this.statusEl.setText(`Ollama: ${health.ollama.message}`);
        this.buttonEl.disabled = true;
        return;
      }
      if (!health.qdrant.healthy && !health.qdrant.message.includes("not found")) {
        this.statusEl.setText(`Qdrant: ${health.qdrant.message}`);
        this.buttonEl.disabled = true;
        return;
      }
      const files = this.app.vault.getMarkdownFiles();
      this.statusEl.setText(`Ready to index ${files.length} files`);
      this.buttonEl.disabled = false;
    } catch (error) {
      this.statusEl.setText(
        `Error: ${error instanceof Error ? error.message : "Connection failed"}`
      );
      this.buttonEl.disabled = true;
    }
  }
  async startIndexing() {
    if (this.isIndexing)
      return;
    this.isIndexing = true;
    this.buttonEl.disabled = true;
    this.buttonEl.setText("Indexing...");
    const startTime = Date.now();
    try {
      const stats = await this.indexer.indexVault((current, total, file) => {
        const percent = current / total * 100;
        this.progressEl.style.width = `${percent}%`;
        this.statusEl.setText(`${current}/${total}: ${file}`);
      });
      const duration = ((Date.now() - startTime) / 1e3).toFixed(1);
      this.statusEl.setText(
        `Indexed ${stats.totalDocuments} documents in ${duration}s`
      );
      this.progressEl.style.width = "100%";
      this.buttonEl.setText("Done");
      new import_obsidian6.Notice(
        `Sage AI: Indexed ${stats.totalDocuments} documents in ${duration}s`
      );
    } catch (error) {
      console.error("Indexing error:", error);
      this.statusEl.setText(
        `Error: ${error instanceof Error ? error.message : "Indexing failed"}`
      );
      this.buttonEl.setText("Retry");
      this.buttonEl.disabled = false;
    } finally {
      this.isIndexing = false;
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/LinkSuggestionModal.ts
var import_obsidian7 = require("obsidian");
var LinkSuggestionModal = class extends import_obsidian7.Modal {
  constructor(app, currentFile, linkService) {
    super(app);
    this.suggestions = [];
    this.isLoading = false;
    this.currentFile = currentFile;
    this.linkService = linkService;
  }
  async onOpen() {
    console.log("[LinkSuggestionModal] Modal opened for file:", this.currentFile.path);
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("sage-ai-link-modal");
    const header = contentEl.createDiv("sage-ai-modal-header");
    header.createEl("h2", { text: "Link Suggestions" });
    header.createEl("p", {
      text: `Finding documents related to "${this.currentFile.basename}"`,
      cls: "sage-ai-modal-description"
    });
    const statusEl = contentEl.createDiv("sage-ai-link-status");
    statusEl.setText("\u{1F50D} Searching for related documents...");
    const resultsEl = contentEl.createDiv("sage-ai-link-results");
    this.isLoading = true;
    try {
      console.log("[LinkSuggestionModal] Calling findSimilarDocuments...");
      this.suggestions = await this.linkService.findSimilarDocuments(
        this.currentFile,
        8
      );
      console.log("[LinkSuggestionModal] Got suggestions:", this.suggestions.length);
      this.isLoading = false;
      if (this.suggestions.length === 0) {
        statusEl.setText("No related documents found");
        resultsEl.empty();
        return;
      }
      statusEl.setText(
        `\u2705 Found ${this.suggestions.length} related document${this.suggestions.length > 1 ? "s" : ""}`
      );
      this.renderSuggestions(resultsEl);
    } catch (error) {
      this.isLoading = false;
      statusEl.setText("\u274C Error finding suggestions");
      console.error("Link suggestion error:", error);
      new import_obsidian7.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  renderSuggestions(container) {
    container.empty();
    this.suggestions.forEach((suggestion, index) => {
      const item = container.createDiv("sage-ai-link-item");
      const headerRow = item.createDiv("sage-ai-link-header");
      const titleEl = headerRow.createDiv("sage-ai-link-title");
      titleEl.setText(`${index + 1}. ${suggestion.file.basename}`);
      const scoreEl = headerRow.createDiv("sage-ai-link-score");
      scoreEl.setText(`${(suggestion.score * 100).toFixed(1)}%`);
      const wikilinkRow = item.createDiv("sage-ai-link-wikilink");
      const wikilinkCode = wikilinkRow.createEl("code");
      wikilinkCode.setText(suggestion.wikilink);
      const copyBtn = wikilinkRow.createEl("button", {
        text: "\u{1F4CB} Copy",
        cls: "sage-ai-copy-btn"
      });
      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(suggestion.wikilink);
        new import_obsidian7.Notice("Wikilink copied to clipboard!");
      });
      if (suggestion.snippets && suggestion.snippets.length > 0) {
        const snippetEl = item.createDiv("sage-ai-link-snippet");
        let snippet = suggestion.snippets[0].replace(/\n/g, " ").trim();
        if (snippet.length > 150) {
          snippet = snippet.slice(0, 150) + "...";
        }
        snippetEl.setText(snippet);
      }
      item.addEventListener("click", (e) => {
        if (!e.target.classList.contains("sage-ai-copy-btn")) {
          this.app.workspace.getLeaf().openFile(suggestion.file);
          this.close();
        }
      });
    });
    const helpEl = container.createDiv("sage-ai-link-help");
    helpEl.setText(
      "\u{1F4A1} Click a document to open it, or click \u{1F4CB} Copy to copy the wikilink"
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  ollamaUrl: "http://127.0.0.1:11434",
  ollamaModel: "bge-m3",
  qdrantUrl: "http://127.0.0.1:6333",
  qdrantCollection: "obsidian_docs",
  maxResults: 8,
  minScore: 0.3
};
var SageAIPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    await this.loadSettings();
    this.initializeServices();
    this.addRibbonIcon("search", "Sage AI Search", () => {
      this.openSearchModal();
    });
    this.addCommand({
      id: "sage-ai-search",
      name: "Semantic Search",
      callback: () => {
        this.openSearchModal();
      }
    });
    this.addCommand({
      id: "sage-ai-jump",
      name: "Jump to Document",
      callback: () => {
        new JumpModal(this.app).open();
      }
    });
    this.addCommand({
      id: "sage-ai-reindex",
      name: "Rebuild Index",
      callback: () => {
        new IndexModal(this.app, this.indexer).open();
      }
    });
    this.addCommand({
      id: "sage-ai-suggest-links",
      name: "Suggest Links for Current Note",
      editorCallback: () => {
        this.openLinkSuggestionModal();
      }
    });
    this.addCommand({
      id: "sage-ai-status",
      name: "Check Connection Status",
      callback: async () => {
        await this.checkStatus();
      }
    });
    this.addSettingTab(new SageAISettingTab(this.app, this));
  }
  initializeServices() {
    this.ollama = new OllamaService({
      baseUrl: this.settings.ollamaUrl,
      model: this.settings.ollamaModel
    });
    this.qdrant = new QdrantService({
      baseUrl: this.settings.qdrantUrl,
      collection: this.settings.qdrantCollection
    });
    this.indexer = new DocumentIndexer({
      ollama: this.ollama,
      qdrant: this.qdrant,
      app: this.app
    });
    this.linkSuggestion = new LinkSuggestionService(
      this.app.vault,
      this.ollama,
      this.qdrant
    );
  }
  async openSearchModal() {
    const health = await this.indexer.healthCheck();
    if (!health.ollama.healthy) {
      new import_obsidian8.Notice(`Sage AI: ${health.ollama.message}`);
      return;
    }
    if (!health.qdrant.healthy) {
      new import_obsidian8.Notice(`Sage AI: ${health.qdrant.message}. Run "Rebuild Index" first.`);
      return;
    }
    new SearchModal(
      this.app,
      this.indexer,
      this.settings.maxResults,
      this.settings.minScore
    ).open();
  }
  async openLinkSuggestionModal() {
    console.log("[SageAI] Opening Link Suggestion Modal");
    const activeFile = this.app.workspace.getActiveFile();
    console.log("[SageAI] Active file:", activeFile == null ? void 0 : activeFile.path);
    if (!activeFile) {
      console.warn("[SageAI] No active file");
      new import_obsidian8.Notice("No active file");
      return;
    }
    console.log("[SageAI] Performing health check...");
    const health = await this.indexer.healthCheck();
    console.log("[SageAI] Health check result:", health);
    if (!health.ollama.healthy) {
      console.warn("[SageAI] Ollama not healthy:", health.ollama.message);
      new import_obsidian8.Notice(`Sage AI: ${health.ollama.message}`);
      return;
    }
    if (!health.qdrant.healthy) {
      console.warn("[SageAI] Qdrant not healthy:", health.qdrant.message);
      new import_obsidian8.Notice(`Sage AI: ${health.qdrant.message}. Run "Rebuild Index" first.`);
      return;
    }
    console.log("[SageAI] Opening modal...");
    new LinkSuggestionModal(
      this.app,
      activeFile,
      this.linkSuggestion
    ).open();
  }
  async checkStatus() {
    new import_obsidian8.Notice("Sage AI: Checking connections...");
    try {
      const health = await this.indexer.healthCheck();
      const stats = await this.indexer.getStats();
      let message = "Sage AI Status:\n";
      message += `
Ollama: ${health.ollama.healthy ? "\u2713" : "\u2717"} ${health.ollama.message}`;
      message += `
Qdrant: ${health.qdrant.healthy ? "\u2713" : "\u2717"} ${health.qdrant.message}`;
      if (stats) {
        message += `

Indexed documents: ${stats.totalDocuments}`;
      }
      new import_obsidian8.Notice(message, 1e4);
    } catch (error) {
      new import_obsidian8.Notice(
        `Sage AI: Error checking status - ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.ollama) {
      this.ollama.updateConfig({
        baseUrl: this.settings.ollamaUrl,
        model: this.settings.ollamaModel
      });
    }
    if (this.qdrant) {
      this.qdrant.updateConfig({
        baseUrl: this.settings.qdrantUrl,
        collection: this.settings.qdrantCollection
      });
    }
  }
};
var SageAISettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Sage AI Settings" });
    containerEl.createEl("h3", { text: "Ollama Configuration" });
    new import_obsidian8.Setting(containerEl).setName("Ollama URL").setDesc("URL of your Ollama server").addText(
      (text) => text.setPlaceholder("http://127.0.0.1:11434").setValue(this.plugin.settings.ollamaUrl).onChange(async (value) => {
        this.plugin.settings.ollamaUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Embedding Model").setDesc("Ollama model for generating embeddings (bge-m3 recommended)").addText(
      (text) => text.setPlaceholder("bge-m3").setValue(this.plugin.settings.ollamaModel).onChange(async (value) => {
        this.plugin.settings.ollamaModel = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Qdrant Configuration" });
    new import_obsidian8.Setting(containerEl).setName("Qdrant URL").setDesc("URL of your Qdrant server").addText(
      (text) => text.setPlaceholder("http://127.0.0.1:6333").setValue(this.plugin.settings.qdrantUrl).onChange(async (value) => {
        this.plugin.settings.qdrantUrl = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Collection Name").setDesc("Qdrant collection name for storing vectors").addText(
      (text) => text.setPlaceholder("obsidian_docs").setValue(this.plugin.settings.qdrantCollection).onChange(async (value) => {
        this.plugin.settings.qdrantCollection = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Search Configuration" });
    new import_obsidian8.Setting(containerEl).setName("Max Results").setDesc("Maximum number of search results to return").addSlider(
      (slider) => slider.setLimits(1, 20, 1).setValue(this.plugin.settings.maxResults).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxResults = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Minimum Score").setDesc("Minimum similarity score for results (0-1)").addSlider(
      (slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.minScore).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.minScore = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Connection Test" });
    new import_obsidian8.Setting(containerEl).setName("Test Connections").setDesc("Test connection to Ollama and Qdrant servers").addButton(
      (button) => button.setButtonText("Test").onClick(async () => {
        button.setButtonText("Testing...");
        button.setDisabled(true);
        try {
          const ollama = new OllamaService({
            baseUrl: this.plugin.settings.ollamaUrl,
            model: this.plugin.settings.ollamaModel
          });
          const qdrant = new QdrantService({
            baseUrl: this.plugin.settings.qdrantUrl,
            collection: this.plugin.settings.qdrantCollection
          });
          const [ollamaHealth, qdrantHealth] = await Promise.all([
            ollama.healthCheck(),
            qdrant.healthCheck()
          ]);
          let message = "";
          message += `Ollama: ${ollamaHealth.healthy ? "\u2713" : "\u2717"} ${ollamaHealth.message}
`;
          message += `Qdrant: ${qdrantHealth.healthy ? "\u2713" : "\u2717"} ${qdrantHealth.message}`;
          new import_obsidian8.Notice(message, 8e3);
        } catch (error) {
          new import_obsidian8.Notice(
            `Error: ${error instanceof Error ? error.message : "Test failed"}`
          );
        } finally {
          button.setButtonText("Test");
          button.setDisabled(false);
        }
      })
    );
  }
};
